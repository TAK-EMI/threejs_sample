<!DOCTYPE html>
<html lang="ja">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>テンプレート</title>
	<script src="../lib/three.min.js"></script>
	<script src="../lib/js/controls/OrbitControls.js"></script>
	<script src="../lib/js/controls/TransformControls.js"></script>
</head>

<body>
	<a href="https://tak-emi.github.io/threejs_sample/">戻る</a><br>
	<form action="" id="form">
		<input type="radio" id="translate" name="transform" checked onclick="update()">移動
		<input type="radio" id="rotate" name="transform" onclick="update()">回転
		<input type="radio" id="scale" name="transform" onclick="update()">拡縮
		<br>
		<input type="button" value="選択解除" onclick="onUnSelect()">
	</form>
	<canvas id="canvas"></canvas>
	<script>
		const width = 500;
		const height = 300;
		const elCanvas = document.querySelector("#canvas");

		var grid, axis;
		var scene = new THREE.Scene();
		var control;
		var mouse = new THREE.Vector2();
		var mouseOverObject;
		var isSelect = false;
	</script>
	<script>
		function onMouseMove(event) {
			const element = event.currentTarget;

			const x = event.pageX - element.offsetLeft;
			const y = event.pageY - element.offsetTop;

			const w = element.offsetWidth;
			const h = element.offsetHeight;

			mouse.x = ( x / w ) * 2 - 1;
			mouse.y = -( y / h ) * 2 + 1;
		}
		function onMouseDown(event) {
			if(mouseOverObject) {
				console.log('attach');
				control.attach(mouseOverObject);
				isSelect = true;
			}else {
				console.log('detach');
				control.detach();
				isSelect = false;
			}
		}
		elCanvas.addEventListener('mousemove', onMouseMove, false);
		elCanvas.addEventListener('mousedown', onMouseDown);
	</script>
	<script>
		function onUnSelect() {
			if(mouseOverObject) {
				mouseOverObject.material.color.set(0x800080);
			}

			mouseOverObject = null;

			control.detach();
			isSelect = false;
		}
		function update() {
			const elTranslate = document.querySelector('#translate');
			const elRotate = document.querySelector('#rotate');
			const elScale = document.querySelector('#scale');

			if (elTranslate.checked === true) {
				control.setMode("translate");
			} else if (elRotate.checked === true) {
				control.setMode("rotate");
			} else if (elScale.checked === true) {
				control.setMode("scale");
			}
		}
		function initBox() {
			const max = 100;
			for(i=0; i<max; i++) {
				const box = new THREE.Mesh(
					new THREE.BoxGeometry(1, 1, 1),
					new THREE.MeshLambertMaterial({ color: 0x800080 })
				);

				const z = (Math.random() * 2) - 1;
				const phi = Math.random() * (2 * Math.PI);
				const r = Math.random();

				box.position.set((Math.pow(r, 1/3) * Math.sqrt(1 - z * z) * Math.cos(phi)) * 10, (Math.pow(r, 1/3) * Math.sqrt(1 - z * z) * Math.sin(phi)) * 10, (Math.pow(r, 1/3) * z) * 10);
				scene.add(box);
			}

			scene.add(control);

			update();

			return;
		}
	</script>
	<script>
		var camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 10000);

		camera.position.set(10, 10, 10);

		var grid = new THREE.GridHelper(100, 100);
		scene.add(grid);

		var axis = new THREE.AxesHelper(1000);
		scene.add(axis);

		const light = new THREE.DirectionalLight(0xffffff);
		light.intensity = 2;
		light.position.set(2, 2, 1);
		scene.add(light);

		var renderer = new THREE.WebGLRenderer({
			canvas: elCanvas
		});
		renderer.setSize(width, height);
		renderer.setClearColor(0xaaaaaa);

		const orbit = new THREE.OrbitControls(camera, renderer.domElement);
		orbit.update();

		control = new THREE.TransformControls(camera, renderer.domElement);
		control.addEventListener('change', animate);
		control.addEventListener('dragging-changed', function (event) {
			orbit.enabled = !event.value;
		});

		initBox();

		function animate() {
			requestAnimationFrame(animate);

			camera.updateMatrixWorld();

			if(isSelect === false) {
				let raycaster = new THREE.Raycaster();
				raycaster.setFromCamera(mouse, camera);

				var intersects = raycaster.intersectObjects(scene.children).filter(element => (element.object != grid && element.object != axis));
				if(intersects.length > 0) {
					let inter = intersects[0].object;
					if(mouseOverObject != inter) {
						if(mouseOverObject) {
							mouseOverObject.material.color.set(0x800080);
						}

						mouseOverObject = inter;
						mouseOverObject.material.color.set(0xffff00);
					}
				}else {
					if(mouseOverObject) {
						mouseOverObject.material.color.set(0x800080);
					}

					mouseOverObject = null;
				}
			}

			orbit.update();

			renderer.render(scene, camera);
		}

		animate();
	</script>
</body>

</html>
